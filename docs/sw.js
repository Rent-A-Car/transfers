const Static_CACHE_Version="21-02-01",Static_CACHE="static-21-02-01",Static_CACHEAssets=["/","/offline.html","/css/main.css","/css/iconsfont.css","/css/RobotoSlab.css","/css/bootstrap.min.css","/js/main.js","/js/menu.js","/js/ucsv.js","/js/router.js","https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js","/favicon.ico","/icons/android-chrome-192x192.png","/icons/apple-touch-icon-precomposed.png","/icons/GoogleLogo.svg","/css/fonts/iconsfont.woff2","/css/fonts/iconsfont.woff","https://fonts.gstatic.com/s/robotoslab/v12/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjojISma2RjRdE.woff2","https://fonts.gstatic.com/s/robotoslab/v12/BngbUXZYTXPIvIBgJJSb6s3BzlRRfKOFbvjojISmb2Rj.woff2","/manifest.webmanifest"],DCACHE="cache-auto",NoCACHEHosts=["apis.google.com","www.googleapis.com","securetoken.googleapis.com"],NoCACHEPaths=["/TermsOfService","/PrivacyPolicy","/cdn-cgi"];async function checkCache(e){if("GET"==e.method){let t=new URL(e.url),s=e;location.hostname==t.hostname&&(t.search="","/index.html"==t.pathname&&(t.pathname="/"),s=new Request(t.toString(),{cache:e.cache,context:e.context,credentials:e.credentials,headers:e.headers,integrity:e.integrity,method:e.method,redirect:e.redirect,referrer:e.referrer,referrerPolicy:e.referrerPolicy,body:e.body,bodyUsed:e.bodyUsed}));const o=await caches.open(Static_CACHE);return await o.match(s||e)||checkOnline(s||e)}return await fetch(e)}async function checkOnline(e){const t=await caches.open(DCACHE);try{let s=new URL(e.url);const o=await fetch(e);if(console.log("fetch to",e.url),!navigator.onLine)throw"Offline";let c=NoCACHEHosts.includes(s.hostname),a=NoCACHEHosts.filter((e,t,o,c=s.pathname)=>c.match(e)).length>0;return c||a?console.log("noCACHED"):await t.put(e,o.clone()),o}catch(s){console.log(s);const o=await t.match(e);if(o)return o;{let t=new URL(e.url).pathname.match(/\.\w+/);return t&&".html"!=t?new Response(new Blob,{status:503,statusText:"You Offline!"}):await caches.match("/offline.html")}}}self.addEventListener("install",async e=>{const t=await caches.open(Static_CACHE);let s=0;for(var o=0;o<5;o++)try{await t.addAll(Static_CACHEAssets);break}catch(e){console.log(e,s),s+=1}if(5==s)for(o=0;o<Static_CACHEAssets.length;o++)try{await t.add(Static_CACHEAssets[o])}catch(e){console.log(e,Static_CACHEAssets[o])}else console.log("Service worker fetch ok");console.log("Service worker встановлено")}),self.addEventListener("activate",async e=>{const t=(await caches.keys()).map(async e=>{[Static_CACHE].includes(e)||await caches.delete(e)});await Promise.all(t),console.log("Service worker актевовано (видалено застарілий кеш)")}),self.addEventListener("fetch",e=>{e.respondWith(checkCache(e.request))});